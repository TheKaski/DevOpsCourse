In this excercise implementation LLM tool was used in the following ways:

Too used - ChatGPT

Reason to use LLM:
I implemented this exercise with completely new language
for me which was the Golang used in the service 2. 
I also avoided to use languages which I already knew how to implement http
services with which led to me creating the service 1 with python.
LLM in this context was used with the programming part as a learning tool for new languages.

How LLM helped:
LLM helped me to relatively fast figure out how Go works, as a statically typed language
the way  Go uses structs was probably the biggest new thing in Go language which I faced with my implementation.
Also as new language I learned how to build Go projects and that Golang in docker
could be run in multiple stages with minimal images which don't contain for  example the additional
linux commands which I used in this exercise. LLM in this part helped so that I managed to 
try new things and find good explanations to my errors with new language relatively fast
to learn as much as possible with this exercise.

What kind of mistakes LLM did:
I noticed that LLM isn't always the best detecting reasons for errors within your implementation
I had one error where I didn't realize to give the return type in Go function declaration
which led to weird error messages with the return statement that too many return values were given.
LLM decided that the reason was how the output from the linux commands were handled. I soon discovered my self that
in Go the type must be given to the function declaration.

LLM also gave me example of a dockerfile for go as a multistage build which of course worked,
however it wasn't ideal for this project as the go application required the basic linux commands
from docker container which the lean mutlistage build got rid of.

What were things that LLM was not able to provide:
I think often times LLM tends to give you examples with generic installed libraries for example
but I personally want to avoid unnecessary libraries with simple projects like this
inorder to keep the implementation clean I think this is something LLM tools often struggle with


